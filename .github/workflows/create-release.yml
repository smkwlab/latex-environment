---
name: Create Release and Update Dependencies

env:
  # LaTeX環境に不要なファイル（一元管理）
  NON_STUDENT_FILES: |
    .github/workflows/check-texlive-updates.yml
    .github/workflows/create-release.yml
    .github/BRANCH_NAMING.md
    .claude/
    DEPENDENCY-UPDATE.md
    VERSIONS.md
    CHANGELOG.md
    CLAUDE.md
    docs/
    main.tex

on:
  push:
    branches:
      - main
    paths-ignore:
      - '.github/workflows/check-texlive-updates.yml'
      - '.github/workflows/create-release.yml'
      - '.github/BRANCH_NAMING.md'
      - '.claude/**'
      - 'DEPENDENCY-UPDATE.md'
      - 'VERSIONS.md'
      - 'CHANGELOG.md'
      - 'CLAUDE.md'
      - 'docs/**'
      - 'main.tex'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_UPDATE_TOKEN || github.token }}

      - name: Check if this is a latex environment update
        id: check
        run: |
          # Check if any latex environment files were updated
          # This works for both direct commits and merge commits
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files: $CHANGED_FILES"

          # Check for devcontainer.json updates (texlive updates)
          if echo "$CHANGED_FILES" | grep -q "\.devcontainer/devcontainer\.json"; then
            echo "devcontainer.json was updated - texlive update detected"
            echo "update_type=texlive" >> $GITHUB_OUTPUT

            # Validate devcontainer.json format first
            if [ ! -f ".devcontainer/devcontainer.json" ]; then
              echo "Error: devcontainer.json not found"
              exit 1
            fi

            # Remove JSONC comments for jq processing
            TEMP_JSON=$(mktemp)
            trap 'rm -f "$TEMP_JSON"' EXIT
            
            # Strip JSONC comments and empty lines for jq processing
            # Optimized: single pass with tee for efficiency and debugging
            sed -e 's|//.*||g' -e '/^\s*$/d' .devcontainer/devcontainer.json | \
              tee "$TEMP_JSON" | jq empty 2>/dev/null
            
            if [ $? -ne 0 ]; then
              echo "Error: Invalid JSON format in devcontainer.json (after comment removal)"
              echo "Debug: First few lines of processed JSON:"
              head -5 "$TEMP_JSON" 2>/dev/null || echo "Unable to read processed JSON"
              echo ""
              echo "Original file excerpt around comments:"
              grep -n "//" .devcontainer/devcontainer.json | head -3 || echo "No // comments found"
              exit 1
            fi

            # Get the actual texlive version using secure parsing
            NEW_VERSION=$(jq -r '.image // empty' "$TEMP_JSON" | \
              sed -n 's/.*texlive-ja-textlint://p')

            # Validate extracted version
            if [ -z "$NEW_VERSION" ]; then
              echo "Error: Could not extract texlive version from devcontainer.json"
              exit 1
            fi

            # Validate version format
            if [[ ! "$NEW_VERSION" =~ ^[0-9]{4}[a-z]*$ ]]; then
              echo "Error: Invalid texlive version format: $NEW_VERSION"
              exit 1
            fi

            echo "Current texlive version in devcontainer.json: $NEW_VERSION"

            if [[ -n "$NEW_VERSION" ]]; then
              echo "texlive_update=true" >> $GITHUB_OUTPUT
              echo "texlive_version=$NEW_VERSION" >> $GITHUB_OUTPUT

              # Get current latex-environment version from latest tag
              CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.4.1")
              echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT

              # Generate new version (increment patch) with validation
              if [[ "$CURRENT_TAG" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
                MAJOR=${BASH_REMATCH[1]}
                MINOR=${BASH_REMATCH[2]}
                PATCH=$((BASH_REMATCH[3] + 1))

                # Validate version components
                if [ "$MAJOR" -lt 0 ] || [ "$MAJOR" -gt 999 ] || \
                   [ "$MINOR" -lt 0 ] || [ "$MINOR" -gt 999 ] || \
                   [ "$PATCH" -lt 0 ] || [ "$PATCH" -gt 9999 ]; then
                  echo "Error: Invalid version component detected"
                  exit 1
                fi

                NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
              else
                echo "Warning: Could not parse current tag '$CURRENT_TAG', using default"
                NEW_TAG="v0.5.0"
              fi
              echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

              echo "Detected texlive update: $NEW_VERSION"
              echo "Will create release: $NEW_TAG"
            else
              echo "environment_update=false" >> $GITHUB_OUTPUT
              echo "No valid texlive version found in devcontainer.json"
            fi
          
          # Check for other latex environment file updates
          elif echo "$CHANGED_FILES" | grep -E "\.(vscode|cspell|textlintrc|latexmkrc)" >/dev/null || \
               echo "$CHANGED_FILES" | grep -E "\.tex$|\.sty$|\.bib$" >/dev/null || \
               echo "$CHANGED_FILES" | grep -E "\.github/workflows/.*\.yml$" >/dev/null; then
            echo "LaTeX environment files updated - environment update detected"
            echo "update_type=environment" >> $GITHUB_OUTPUT
            echo "environment_update=true" >> $GITHUB_OUTPUT
            
            # Generate environment update version
            CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null)
            if [[ -z "$CURRENT_TAG" ]]; then
              echo "Warning: No tags found, starting from v0.1.0"
              NEW_TAG="v0.1.0"
            elif [[ "$CURRENT_TAG" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              MAJOR=${BASH_REMATCH[1]}
              MINOR=${BASH_REMATCH[2]}
              PATCH=$((BASH_REMATCH[3] + 1))
              NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
            else
              echo "Warning: Invalid tag format '$CURRENT_TAG', incrementing patch version"
              # Extract numeric part and increment
              VERSION_NUM=$(echo "$CURRENT_TAG" | sed 's/^v//' | grep -o '^[0-9]\+\.[0-9]\+\.[0-9]\+')
              if [[ -n "$VERSION_NUM" ]]; then
                if [[ "$VERSION_NUM" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
                  MAJOR=${BASH_REMATCH[1]}
                  MINOR=${BASH_REMATCH[2]}
                  PATCH=$((BASH_REMATCH[3] + 1))
                  NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
                else
                  NEW_TAG="v0.1.0"
                fi
              else
                NEW_TAG="v0.1.0"
              fi
            fi
            echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT
            echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
            echo "Will create environment release: $NEW_TAG"
          
          else
            echo "environment_update=false" >> $GITHUB_OUTPUT
            echo "No latex environment files were updated"
          fi

      - name: Update release branch
        if: steps.check.outputs.environment_update == 'true'
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          # Create or update release branch (remove management files, keep user files)
          git checkout -B release

          # Remove non-latex environment files using centralized list
          echo "${{ env.NON_STUDENT_FILES }}" | while IFS= read -r pattern; do
            [[ -z "$pattern" ]] && continue
            echo "Removing pattern: $pattern"
            # Handle glob patterns and regular files
            if [[ "$pattern" == *"*"* ]]; then
              # Use shell glob expansion for patterns with wildcards
              for file in $pattern; do
                [ -e "$file" ] && rm -rf "$file" || true
              done
            else
              # Direct file/directory removal
              rm -rf "$pattern" 2>/dev/null || true
            fi
          done

          # Enhanced version format validation
          NEW_TAG="${{ steps.check.outputs.new_tag }}"
          if [[ ! "$NEW_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Invalid version format: $NEW_TAG"
            exit 1
          fi

          # Additional length validation
          if [ ${#NEW_TAG} -gt 20 ]; then
            echo "Error: Version tag too long: $NEW_TAG"
            exit 1
          fi

          # Add version file for tracking with secure handling
          TEMP_VERSION=$(mktemp)
          trap 'rm -f "$TEMP_VERSION"' EXIT

          # Create VERSION file content based on update type
          echo "${{ steps.check.outputs.new_tag }}" > "$TEMP_VERSION"
          if [[ "${{ steps.check.outputs.update_type }}" == "texlive" ]]; then
            echo "texlive-ja-textlint: ${{ steps.check.outputs.texlive_version }}" >> "$TEMP_VERSION"
            echo "update-type: texlive" >> "$TEMP_VERSION"
          else
            echo "update-type: environment" >> "$TEMP_VERSION"
          fi
          echo "created: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> "$TEMP_VERSION"

          # Validate content before moving
          if [ -s "$TEMP_VERSION" ]; then
            mv "$TEMP_VERSION" VERSION
          else
            echo "Error: Failed to create VERSION file"
            exit 1
          fi

          git add -A
          if [[ "${{ steps.check.outputs.update_type }}" == "texlive" ]]; then
            git commit -m "Update release branch for texlive-ja-textlint ${{ steps.check.outputs.texlive_version }}" || true
          else
            git commit -m "Update release branch for environment changes ${{ steps.check.outputs.new_tag }}" || true
          fi

          # Push release branch
          git push origin release --force

      - name: Update main branch version files
        if: steps.check.outputs.environment_update == 'true'
        run: |
          git checkout main
          
          # Update VERSION file on main branch (without 'v' prefix to maintain consistency)
          # Tags use 'v' prefix, but VERSION file traditionally doesn't
          echo "${{ steps.check.outputs.new_tag }}" | sed 's/^v//' > VERSION
          
          # Update VERSIONS.md with new compatibility entry
          TEMP_VERSIONS=$(mktemp)
          trap 'rm -f "$TEMP_VERSIONS"' EXIT
          
          # Read current VERSIONS.md and insert new entry
          if [ -f "VERSIONS.md" ]; then
            # Create updated VERSIONS.md with new entry at top of version table
            # More robust approach that doesn't depend on line numbers
            awk -v new_version="${{ steps.check.outputs.new_tag }}" \
                -v texlive_version="${{ steps.check.outputs.texlive_version }}" '
            BEGIN { 
              inserted = 0
              header_found = 0
              in_table = 0
            }
            # Detect table header
            /^\| *latex-environment *\|/ { 
              header_found = 1
              print
              next
            }
            # Detect header separator and start of table content
            header_found && /^\|[-: ]+\|/ {
              in_table = 1
              print
              next
            }
            # Insert new version at the beginning of table content
            in_table && /^\|/ {
              if (!inserted) {
                if ("${{ steps.check.outputs.update_type }}" == "texlive") {
                  print "| " new_version " (current) | " texlive_version " | 2025 | Automated texlive update |"
                } else {
                  print "| " new_version " (current) | - | 2025 | Environment configuration update |"
                }
                inserted = 1
              }
              # Remove (current) marker from previous entries
              gsub(/\(current\)/, "")
              print
              next
            }
            # Print all other lines as-is
            { print }
            ' VERSIONS.md > "$TEMP_VERSIONS"
            
            # Validate and update VERSIONS.md
            if [ -s "$TEMP_VERSIONS" ]; then
              mv "$TEMP_VERSIONS" VERSIONS.md
              echo "Updated VERSIONS.md with ${{ steps.check.outputs.new_tag }} entry"
            else
              echo "Warning: Failed to update VERSIONS.md, using original"
            fi
          else
            echo "Warning: VERSIONS.md not found, skipping update"
          fi
          
          # Commit version file updates to main branch
          git add VERSION VERSIONS.md
          git commit -m "Auto-update version files for ${{ steps.check.outputs.new_tag }}

          - Update VERSION to ${{ steps.check.outputs.new_tag }}
          - Update VERSIONS.md compatibility matrix
          - Add texlive-ja-textlint:${{ steps.check.outputs.texlive_version }} mapping

          Automated by create-release workflow" || true
          
          # Push main branch updates
          git push origin main

      - name: Create release tag
        if: steps.check.outputs.environment_update == 'true'
        run: |
          git tag ${{ steps.check.outputs.new_tag }}
          git push origin ${{ steps.check.outputs.new_tag }}

      - name: Create GitHub release
        if: steps.check.outputs.environment_update == 'true'
        run: |
          # Generate release notes based on update type
          if [[ "${{ steps.check.outputs.update_type }}" == "texlive" ]]; then
            RELEASE_NOTES=$(cat <<EOF
          ## 🚀 LaTeX Environment ${{ steps.check.outputs.new_tag }}
          
          **Automated Release** - Updated texlive-ja-textlint dependency
          
          ### 📦 Changes
          - **texlive-ja-textlint**: Updated to \`${{ steps.check.outputs.texlive_version }}\`
          - **VERSION file**: Synchronized to \`${{ steps.check.outputs.new_tag }}\`
          - **VERSIONS.md**: Updated compatibility matrix
          
          ### 🔄 Automated Updates
          - ✅ Release branch updated for template users
          - ✅ VERSION files synchronized across branches
          - ✅ Compatibility matrix updated
          - ✅ aldc integration ready
          
          ### 📚 Usage
          
          **For new repositories (recommended):**
          - Use [aldc](https://github.com/smkwlab/aldc) for automated setup
          - Or use GitHub template from this release
          
          **For existing repositories:**
          - Update \`.devcontainer/devcontainer.json\` image to \`ghcr.io/smkwlab/texlive-ja-textlint:${{ steps.check.outputs.texlive_version }}\`
          
          ---
          *This release was automatically created by the dependency update system.*
          EOF
          )
          else
            RELEASE_NOTES=$(cat <<EOF
          ## 🚀 LaTeX Environment ${{ steps.check.outputs.new_tag }}
          
          **Automated Release** - Updated environment configuration
          
          ### 📦 Changes
          - **Environment**: Updated configuration files for improved development experience
          - **VERSION file**: Synchronized to \`${{ steps.check.outputs.new_tag }}\`
          - **VERSIONS.md**: Updated compatibility matrix
          
          ### 🔄 Automated Updates
          - ✅ Release branch updated for template users
          - ✅ VERSION files synchronized across branches
          - ✅ Environment configuration updated
          - ✅ aldc integration ready
          
          ### 📚 Usage
          
          **For new repositories (recommended):**
          - Use [aldc](https://github.com/smkwlab/aldc) for automated setup
          - Or use GitHub template from this release
          
          **For existing repositories:**
          - Pull latest changes to get updated environment configuration
          
          ---
          *This release was automatically created by the environment update system.*
          EOF
          )
          fi
          
          gh release create ${{ steps.check.outputs.new_tag }} \
            --title "LaTeX Environment ${{ steps.check.outputs.new_tag }}" \
            --notes "$RELEASE_NOTES" \
            --prerelease=false
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Verify version synchronization
        if: steps.check.outputs.environment_update == 'true'
        run: |
          echo "🔍 Verifying version file synchronization..."
          
          # Check VERSION file on main branch
          MAIN_VERSION=$(cat VERSION)
          echo "VERSION file on main: $MAIN_VERSION"
          
          # Check release tag
          RELEASE_TAG="${{ steps.check.outputs.new_tag }}"
          echo "Created release tag: $RELEASE_TAG"
          
          # Verify synchronization (VERSION file doesn't have 'v' prefix)
          EXPECTED_VERSION=$(echo "$RELEASE_TAG" | sed 's/^v//')
          if [ "$MAIN_VERSION" = "$EXPECTED_VERSION" ]; then
            echo "✅ Version files are synchronized"
            echo "  VERSION file: $MAIN_VERSION"
            echo "  Release tag: $RELEASE_TAG"
          else
            echo "❌ Version synchronization failed!"
            echo "  VERSION file: $MAIN_VERSION"
            echo "  Expected: $EXPECTED_VERSION"
            echo "  Release tag: $RELEASE_TAG"
            exit 1
          fi
          
          # Check VERSIONS.md update
          if grep -q "$RELEASE_TAG" VERSIONS.md; then
            echo "✅ VERSIONS.md updated successfully"
          else
            echo "⚠️ VERSIONS.md may not have been updated properly"
          fi

      - name: Summary
        if: steps.check.outputs.environment_update == 'true'
        run: |
          echo "🎉 Successfully created latex-environment release ${{ steps.check.outputs.new_tag }}"
          echo ""
          echo "Summary:"
          if [[ "${{ steps.check.outputs.update_type }}" == "texlive" ]]; then
            echo "  ✅ Updated release branch with texlive-ja-textlint: ${{ steps.check.outputs.texlive_version }}"
          else
            echo "  ✅ Updated release branch with environment configuration changes"
          fi
          echo "  ✅ Updated VERSION file on main branch: ${{ steps.check.outputs.new_tag }}"
          echo "  ✅ Updated VERSIONS.md compatibility matrix"
          echo "  ✅ Created release tag and GitHub release"
          echo "  ✅ Version files synchronized across branches"
          echo ""
          echo "📦 aldc will now provide updated environment to new repositories"
          echo "🎉 Complete automation chain with version synchronization is now active!"
